var Scope = require('./scope.js').Scope;
var Symbol = require('./symbol.js').Symbol;

// Helper function used to convert all arguments of a function into a single array.
function argsToArray(args) {
    return [].slice.call(args, 0);
}

/*
 * Runtime constructor.
 *
 **/
var Runtime = exports.Runtime = function() {
    this.createGlobalScope();
}

/*
 * Evaluates an s-expression from the parse tree generated by the parser.
 *
 * */
Runtime.prototype.eval = function(expression, scope) {
    var self = this,
        varName; // it can be a function, a symbol or a value

    if (!scope) {
        scope = this.globalScope;
    }

    if (typeof expression.name !== 'undefined') {
        varName = expression.name;

        if (!this.isKeyword(varName)) {
            return scope.find(varName);
        }
    }
    else if (!Array.isArray(expression)) {
        return expression;
    }
    else if (expression[0] == 'if') {
        varName = 'if';
    } else if (typeof expression[0].name !== 'undefined') {
        varName = expression[0].name;
    }

    /*
     * If the value of the var name wasn't found in the scope or evaluated yet, it is a 
     * special form and is implemented in JavaScript.
     *
     * */
    var formName = varName;
    switch (formName) {
        case 'quote':
            return expression[1];

        case '=':
            var test = scope.find(expression[0].name),
                op1 = expression[1],
                op2 = expression[2];
            return test(op1, op2);
        case 'if':
            var test = expression[1],
                conseq = expression[2],
                alt = expression[3],
                branch = this.eval(test, scope) ? conseq : alt;

            return this.eval(branch, scope);
        case 'cond':
            return this.eval(this.transformCondIntoIfSeq(expression, scope), scope);
        case 'define':
        case 'set!':
            var symbol = expression[1],
                exp = expression[2],
                value = this.eval(exp, scope);
            scope.set(symbol.name, value);
            break;

        // Evaluates all expressions and returns the value of the last one.
        case 'begin':
           return scope.find('cdr')(expression).map(function(exp) {
                return self.eval(exp, scope);
            }).pop();

        case 'lambda':
            var vars = expression[1],
                exp = expression[2];
            return function() {
                var args = argsToArray(arguments);
                return self.eval(exp, new Scope(vars, args, scope));
            };

        case 'map':
            var fn = this.eval(expression[1]),
                list = this.eval(expression[2]);
            return list.map(fn);

        // Function application
        default:
            var exps = expression.map(function(exp) { return self.eval(exp, scope); }),
                proc = exps.shift();
            return proc.apply(scope, exps);
    }
}

Runtime.prototype.transformCondIntoIfSeq = function (expression, scope) {
    var car = scope.find('car'),
        cdr = scope.find('cdr'),
        cons = scope.find('cons'),
        isNull = scope.find('null?');

    function condClauses(expression) {
        return cdr(expression);
    }

    function condPredicate(clause) {
        return car(clause);
    }

    function isCondElseClause(clause) {
        var pred = condPredicate(clause);
        return pred && pred.name == 'else';
    }

    function condActions(clause) {
        return cdr(clause);
    }

    function makeBegin(seq) {
        return ["begin", seq];
    }

    function makeIf(predicate, conseq, alter) {
        return ['if', predicate, conseq, alter];
    }

    function isLastExpression(seq) {
        return isNull(cdr(seq));
    }

    function firstExpression(seq) {
        return car(seq);
    }

    function transformSeqIntoExp(seq) {
        if (isNull(seq)) {
            return seq;
        } else {
            if (isLastExpression(seq)) {
                return firstExpression(seq);
            } else {
                return makeBegin(seq);
            }
        }
    }

    function error(message, tree) {
        throw message;
    }

    function expandClauses(clauses) {
        if (isNull(clauses)) {
            return "false"
        } else {
            var first = car(clauses),
                rest = cdr(clauses);

            if (isCondElseClause(first)) {
                if (isNull(rest)) {
                    return transformSeqIntoExp(condActions(first));
                } else {
                    error("Else clause isn't last -- COND--IF", clauses)
                }
            } else {
                return makeIf(condPredicate(first),
                                transformSeqIntoExp(condActions(first)),
                                expandClauses(rest));
            }
        }
    }

    return expandClauses(condClauses(expression));
}

/*
 * Creates the global scope object and assigns some defaults built-in functions to it.
 *
 * */
Runtime.prototype.createGlobalScope = function() {
    this.globalScope = new Scope([], [], null);
    this.globalScope.update({
        '+': function() {
            var args = argsToArray(arguments);
            return args.reduce(function(a, b) { return a + b; });
        },

        '-': function() {
            var args = argsToArray(arguments),
                total = args.shift();

            if (args.length === 0) {
                return -total;
            }
            return args.reduce(function(total, a) { return total -= a; }, total);
        },

        '*': function() {
            var args = argsToArray(arguments);
            return args.reduce(function(a, b) { return a * b; });
        },

        '/': function() {
            var args = argsToArray(arguments);
            return args.reduce(function(a, b) { return a / b; });
        },

        'not': function(value) {
            return !value;
        },

        '>': function(a, b) {
            return a > b;
        },

        '<': function(a, b) {
            return a < b;
        },

        '>=': function(a, b) {
            return a >= b;
        },

        '<=': function(a, b) {
            return a <= b;
        },

        '=': function(a, b) {
            return a === b;
        },

        'length': function(list) {
            return list.length;
        },

        'cons': function(first, rest) {
            return [first].concat(rest);
        },

        'car': function(list) {
            return list[0];
        },

        'cdr': function(list) {
            return list.slice(1, list.length);
        },

        'list': function() {
            return [].slice.apply(arguments);
        },

        'null?': function(list) {
            return list.length === 0;
        },

        'true': true,


        'false': false,
    });
}

Runtime.prototype.isKeyword = function(name) {
    var keywords = ['quote', 'if', 'define', 'set!', 'lambda', 'begin', 'map'];
    return keywords.indexOf(name) >= 0;
}
