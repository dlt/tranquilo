var Scope = require('./scope.js').Scope;

// Helper function used to convert all arguments of a function into a single array.
function argsToArray(args) {
    return [].slice.call(args, 0);
}

/*
 * Runtime constructor.
 *
 **/
var Runtime = exports.Runtime = function() {
    this.createGlobalScope();
}

/*
 * Evaluates an s-expression from the parse tree generated by the parser.
 *
 * */
Runtime.prototype.eval = function(expression, scope) {
    var self = this,
        varName; // it can be a function, a symbol or a value

    if (!scope) {
        scope = this.globalScope;
    }

    if (typeof expression.name !== 'undefined') {
        varName = expression.name;

        if (!this.isKeyword(varName)) {
            return scope.find(varName);
        }
    }
    else if (!Array.isArray(expression)) {
        return expression;
    }
    else if (typeof expression[0].name !== 'undefined') {
        varName = expression[0].name;
    }

    /*
     * If the value of the var name wasn't found in the scope or evaluated yet, it is a 
     * special form and is implemented in JavaScript.
     *
     * */
    var formName = varName;
    switch (formName) {
        case 'quote':
            return expression[1];

        case 'if':
            var test = expression[1],
                conseq = expression[2],
                alt = expression[3],
                branch = this.eval(test, scope) ? conseq : alt;
            return this.eval(branch, scope);

        case 'define':
        case 'set!':
            var symbol = expression[1],
                exp = expression[2],
                value = this.eval(exp, scope);
            scope.set(symbol.name, value);
            break;

        // Evaluates all expressions and returns the value of the last one.
        case 'begin':
           return scope.find('cdr').apply(this, [expression]).map(function(exp) {
                return self.eval(exp, scope);
            }).pop();

        case 'lambda':
            var vars = expression[1],
                exp = expression[2];
            return function() {
                var args = argsToArray(arguments);
                return self.eval(exp, new Scope(vars, args, scope));
            };

        case 'map':
            var fn = this.eval(expression[1]),
                list = this.eval(expression[2]);
            return list.map(fn);

        // Function application
        default:
            var exps = expression.map(function(exp) { return self.eval(exp, scope); }),
                proc = exps.shift();
            return proc.apply(scope, exps);
    }
}

/*
 * Creates the global scope object and assigns some defaults built-in functions to it.
 *
 * */
Runtime.prototype.createGlobalScope = function() {
    this.globalScope = new Scope([], [], null);
    this.globalScope.update({
        '+': function() {
            var args = argsToArray(arguments);
            return args.reduce(function(a, b) { return a + b; });
        },

        '-': function() {
            var args = argsToArray(arguments),
                total = args.shift();

            if (args.length === 0) {
                return -total;
            }
            return args.reduce(function(total, a) { return total -= a; }, total);
        },

        '*': function() {
            var args = argsToArray(arguments);
            return args.reduce(function(a, b) { return a * b; });
        },

        '/': function() {
            var args = argsToArray(arguments);
            return args.reduce(function(a, b) { return a / b; });
        },

        'not': function(value) {
            return !value;
        },

        '>': function(a, b) {
            return a > b;
        },

        '<': function(a, b) {
            return a < b;
        },

        '>=': function(a, b) {
            return a >= b;
        },

        '<=': function(a, b) {
            return a <= b;
        },

        '=': function(a, b) {
            return a === b;
        },

        'length': function(list) {
            return list.length;
        },

        'cons': function(first, rest) {
            return [first].concat(rest);
        },

        'car': function(list) {
            return list[0];
        },

        'cdr': function(list) {
            return list.slice(1, list.length);
        },

        'list': function() {
            return [].slice.apply(arguments);
        },

        'null?': function(list) {
            return list.length === 0;
        }
    });
}

Runtime.prototype.isKeyword = function(name) {
    var keywords = ['quote', 'if', 'define', 'set!', 'lambda', 'begin', 'map'];
    return keywords.indexOf(name) >= 0;
}
