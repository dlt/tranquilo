(function () {
    var Scope = require('./scope.js').Scope;
    var Symbol = require('./symbol.js').Symbol;

    'use strict';
    // Helper function used to convert all arguments of a function into a single array.
    function argsToArray(args) {
        return [].slice.call(args, 0);
    }

    /*
     * Runtime constructor.
     *
     **/

    var Runtime = exports.Runtime = function () {
        this.createGlobalScope();
    }

    /*
     * Evaluates an s-expression from the parse tree generated by the parser.
     *
     * */
    Runtime.prototype.eval = function(expression, scope) {
        var self = this,
            varName; // it can be a function, a symbol or a value

        if (!scope) {
            scope = this.globalScope;
        }

        if (typeof expression.name !== 'undefined') {
            varName = expression.name;

            if (!this.isKeyword(varName)) {
                return scope.find(varName);
            }
        }
        else if (!Array.isArray(expression)) {
            return expression;
        }
        else if (typeof expression[0].name !== 'undefined') {
            varName = expression[0].name;
        }

        /*
         * If the value of the var name wasn't found in the scope or evaluated yet, it is a
         * special form and is implemented in JavaScript.
         *
         * */
        var formName = varName;
        switch (formName) {
            case 'quote':
                return expression[1];

            case '=':
                var test = scope.find(expression[0].name),
                    op1 = this.eval(expression[1]),
                    op2 = this.eval(expression[2]);
                return test(op1, op2);
            case 'if':
                var test = expression[1],
                    conseq = expression[2],
                    alt = expression[3],
                    branch = this.eval(test, scope) ? conseq : alt;

                return this.eval(branch, scope);
            case 'cond':
                return this.eval(this.transformCondIntoIfSeq(expression), scope);
            case 'define':
            case 'set!':
                var symbol = expression[1],
                    exp = expression[2],
                    value;

                if (this.isLambda(exp)) {
                    var params = this.lambdaParameters(exp),
                        body = this.lambdaBody(exp);

                    value = this.makeProcedure(params, body, scope);
                } else {
                    value = this.eval(exp, scope);
                }

                scope.set(symbol.name, value);
                break;

            // Evaluates all expressions and returns the value of the last one.
            case 'begin':
                var beginActions = scope.find('cdr')(expression);
                return this.evalSequence(beginActions, scope);

            case 'lambda':
                var params = this.lambdaParameters(expression),
                    body = this.lambdaBody(expression);
                return this.makeProcedure(params, body, scope);

            case 'map':
                var fn = this.eval(expression[1]),
                    list = this.eval(expression[2]);

                return list.map(function(e) {
                    return self.apply(fn, [e]);
                });

            // Function application
            default:
                var exps = expression.map(function(exp) { return self.eval(exp, scope); }),
                    proc = exps.shift();

                if (this.isPrimitiveProcedure(proc)) {
                    proc.scope = scope;
                }
                return this.apply(proc, exps);
        }
    }

    /*
     * Receives a either compound or primitive procedure, and applies its args
     * to it, using the enclosing environment as context.
     *
     */
    Runtime.prototype.apply = function(procedure, args) {
        if (this.isPrimitiveProcedure(procedure)) {
            var result = procedure.apply(procedure.scope, args);
            delete procedure.scope;
            return result;
        }
        else if (this.isCompoundProcedure(procedure)) {
            var body = this.procedureBody(procedure),
                params = this.procedureParameters(procedure),
                env = this.procedureEnvironment(procedure),
                extendedEnvironment = this.extendEnvironment(params, args, env);
            return this.evalSequence(['begin', body], extendedEnvironment);
        }
        else {
            this.error('Bad procedure application! Should never enter here :/');
        }
    }


    /*
     * Creates a new scope using initializing its variables to the ones provided in
     * the 'params' and 'args' variables and set 'outer' as the parent scope.
     */
    Runtime.prototype.extendEnvironment = function(params, args, outer) {
        if (params.name !== undefined && args.length === 1) {
            return new Scope([params.name], args, outer);
        }

        return new Scope(params.map(function(p) { return p.name ? p.name : p; }), args, outer);
    }

    /*
     * Evaluates begin type expressions.
     */
    Runtime.prototype.evalSequence = function(actions, scope) {
        var self = this;
        try {
            return actions.map(function(exp) {
                return self.eval(exp, scope);
            }).pop();
        } catch (e) {
            console.log(e);
        }
    }

    Runtime.prototype.transformCondIntoIfSeq = function (expression) {
        var scope = this.globalScope,
            car = scope.find('car'),
            cdr = scope.find('cdr'),
            cons = scope.find('cons'),
            isNull = scope.find('null?'),
            self = this;

        function condClauses(expression) {
            return cdr(expression);
        }

        function condPredicate(clause) {
            return car(clause);
        }

        function isCondElseClause(clause) {
            var pred = condPredicate(clause);
            return pred && pred.name == 'else';
        }

        function condActions(clause) {
            return cdr(clause);
        }

        function makeIf(predicate, conseq, alter) {
            return [new Symbol('if'), predicate, conseq, alter];
        }

        function isLastExpression(seq) {
            return isNull(cdr(seq));
        }

        function firstExpression(seq) {
            return car(seq);
        }

        function transformSeqIntoExp(seq) {
            if (isNull(seq)) {
                return seq;
            } else {
                if (isLastExpression(seq)) {
                    return firstExpression(seq);
                } else {
                    return self.makeBegin(seq);
                }
            }
        }

        function expandClauses(clauses) {
            if (isNull(clauses)) {
                return 'false';
            } else {
                var first = car(clauses),
                    rest = cdr(clauses);

                if (isCondElseClause(first)) {
                    if (isNull(rest)) {
                        return transformSeqIntoExp(condActions(first));
                    } else {
                        self.error('Else clause isn\'t last -- COND--IF', clauses)
                    }
                } else {
                    return makeIf(condPredicate(first),
                                  transformSeqIntoExp(condActions(first)),
                                  expandClauses(rest));
                }
            }
        }

        return expandClauses(condClauses(expression));
    }

    Runtime.prototype.makeBegin = function(seq) {
        return [new Symbol('begin'), seq];
    }

    /*
     * Creates the global scope object and assigns some defaults built-in functions to it.
     *
     * */
    Runtime.prototype.createGlobalScope = function() {
        this.globalScope = new Scope([], [], null);
        this.globalScope.update({
            '+': function() {
                var args = argsToArray(arguments);
                return args.reduce(function(a, b) { return a + b; });
            },

            '-': function() {
                var args = argsToArray(arguments),
                total = args.shift();

                if (args.length === 0) {
                    return -total;
                }
                return args.reduce(function(total, a) { return total -= a; }, total);
            },

            '*': function() {
                var args = argsToArray(arguments);
                return args.reduce(function(a, b) { return a * b; });
            },

            '/': function() {
                var args = argsToArray(arguments);
                return args.reduce(function(a, b) { return a / b; });
            },

            'not': function(value) {
                return !value;
            },

            '>': function(a, b) {
                return a > b;
            },

            '<': function(a, b) {
                return a < b;
            },

            '>=': function(a, b) {
                return a >= b;
            },

            '<=': function(a, b) {
                return a <= b;
            },

            '=': function(a, b) {
                return a === b;
            },

            'length': function(list) {
                return list.length;
            },

            'cons': function(first, rest) {
                return [first].concat(rest);
            },

            'car': function(list) {
                return list[0];
            },

            'cdr': function(list) {
                return list.slice(1, list.length);
            },

            'list': function() {
                return [].slice.apply(arguments);
            },

            'null?': function(list) {
                return list.length === 0;
            },

            'true': true,


            'false': false,
        });
    }

    Runtime.prototype.isKeyword = function(name) {
        var keywords = ['quote', 'if', 'define', 'set!', 'lambda', 'begin', 'map'];
        return keywords.indexOf(name) >= 0;
    }

    Runtime.prototype.isTaggedList = function(tag, list) {
        return tag == list[0].name;
    }

    Runtime.prototype.isLambda = function(list) {
        return this.isTaggedList('lambda', list);
    }

    Runtime.prototype.lambdaParameters = function(expression) {
        return expression[1];
    }

    Runtime.prototype.lambdaBody = function(expression) {
        return expression[2];
    }

    Runtime.prototype.makeProcedure = function(parameters, body, env) {
        return [new Symbol('procedure'), parameters, body, env];
    }

    Runtime.prototype.isCompoundProcedure = function(exp) {
        return this.isTaggedList('procedure', exp) ||
            this.isTaggedList('lambda', exp);
    }

    Runtime.prototype.procedureParameters = function(expression) {
        return expression[1];
    }

    Runtime.prototype.procedureBody = function(expression) {
        return expression[2];
    }

    Runtime.prototype.procedureEnvironment = function(expression) {
        return expression[3];
    }

    Runtime.prototype.error = function(message, tree) {
        throw message;
    }

    Runtime.prototype.isPrimitiveProcedure = function(procedure) {
        return typeof procedure === 'function';
    }
})();
